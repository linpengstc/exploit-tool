#-*-coding:utf-8-*-
#python parseFunc.py -f 需要解析的文件 -d 文件所在的目录（默认为.）-a 所有函数(默认) -u 未定义函数 -s 非系统函数 -u -s - a三个三参数只能存在一个
#developed by LP
import re;
import getopt;
import sys;
sys_funcs=["script_name","script_version","script_timeout","script_description","script_copyright","script_summary","script_category",
"script_family","script_dependencie","script_dependencies","script_require_keys","script_mandatory_keys","script_require_ports",
"script_require_udp_ports","script_exclude_keys","script_add_preference","script_get_preference","script_get_preference_file_content",
"script_get_preference_file_location","script_id","script_oid","script_cve_id","script_bugtraq_id","script_xref","script_tag","get_preference",
"safe_checks","replace_kb_item","set_kb_item","get_kb_item","get_kb_fresh_item","get_kb_list","security_warning","security_note",
"security_hole","log_message","debug_message","open_sock_tcp","open_sock_udp","open_priv_sock_tcp","open_priv_sock_udp","socket_get_error",
"socket_pending","socketpair","recv","recv_line","send","close","join_multicast_group","leave_multicast_group","get_source_port","cgibin",
"http_open_socket","http_head","http_get","http_post","http_delete","http_put","http_close_socket","get_host_name","get_host_ip","same_host",
"getpid","fork","wait","get_host_open_port","get_port_state","get_tcp_port_state","get_udp_port_state","scanner_add_port","scanner_status",
"scanner_get_port","islocalhost","islocalnet","get_port_transport","this_host","this_host_name","string","raw_string","strcat","display",
"ord","hex","hexstr","strstr","ereg","ereg_replace","egrep","eregmatch","match","substr","insstr","tolower","toupper","crap","strlen",
"split","chomp","int","stridx","str_replace","make_list","make_array","keys","max_index","sort","unixtime","gettimeofday","localtime",
"mktime","open_sock_kdc","telnet_init","ftp_log_in","ftp_get_pasv_port","start_denial","end_denial","dump_ctxt","typeof","exit","rand",
"usleep","sleep","isnull","defined_func","func_named_args","func_unnamed_args","func_has_arg","forge_ip_packet","data","ip_src",
"forge_ipv6_packet","data","ip6_tc","get_ip_element","get_ipv6_element","set_ip_elements","ip","ip_len","ip_sum","set_ipv6_elements",
"ip6","ip6_src","insert_ip_options","insert_ipv6_options","dump_ip_packet","dump_ipv6_packet","forge_tcp_packet","data","th_sport",
"forge_tcp_v6_packet","data","th_seq","th_win","get_tcp_element","element","get_tcp_v6_element","element","set_tcp_elements","data",
"th_sport","set_tcp_v6_elements","data","th_flags","th_sum","dump_tcp_packet","dump_tcp_v6_packet","tcp_ping","tcp_v6_ping","get_dst_mac_addr"
,"forge_udp_packet","data","forge_udp_v6_packet","data","get_udp_element","element","get_udp_v6_element","element","set_udp_elements",
"data","set_udp_v6_elements","data","dump_udp_packet","dump_udp_v6_packet","forge_icmp_packet","data","ip","forge_icmp_v6_packet","data","ip6"
,"get_icmp_element","element","get_icmp_v6_element","element","forge_igmp_packet","code","forge_igmp_v6_packet","code","send_packet","length"
,"send_v6packet","length","pcap_next","send_capture","data","MD2","MD4","MD5","SHA1","RIPEMD160","HMAC_MD2","HMAC_MD5","HMAC_SHA1",
"HMAC_RIPEMD160","NTLMv1_HASH","NTLMv2_HASH","nt_owf_gen","lm_owf_gen","ntv2_owf_gen","dh_generate_key","bn_random","bn_cmp","dh_compute_key",
"rsa_public_decrypt","bf_cbc_encrypt","bf_cbc_decrypt","dsa_do_verify","pem_to_rsa","pem_to_dsa","rsa_sign","dsa_do_sign","pread",
"find_in_path","fread","fwrite","unlink","get_tmp_dir","file_stat","file_open","file_close","file_read","file_write","file_seek",
"shared_socket_register","shared_socket_acquire","shared_socket_release","shared_socket_destroy","wmi_versioninfo","wmi_connect",
"wmi_close","wmi_query","wmi_connect_rsop","wmi_query_rsop","wmi_connect_reg","wmi_reg_enum_key","wmi_reg_enum_value","wmi_reg_get_sz",
"wmi_reg_get_bin_val","wmi_reg_get_dword_val","wmi_reg_get_ex_string_val","wmi_reg_get_mul_string_val","wmi_reg_get_qword_val",
"smb_versioninfo","smb_connect","smb_close","smb_file_SDDL","smb_file_owner_sid","smb_file_group_sid","smb_file_trustee_rights",
"report_tag","hmap_fuzzy_match","scanner_add_service","report_vul","script_get_service_class","script_get_service_dict",
"script_get_token_count","script_get_dict_user","script_get_dict_pass","script_report_pass","gbk_to_utf8","match_cpe_and_report","include","return"]
#筛选出foreach调用，这是要过滤的东西
def addForeaches(line,foreachs):
	p = re.compile("^\s*foreach\s*?(.*?)\s*\(.*\)")
	m = p.match(line)
	if m:
		foreachs.append(m.group(1).strip())
#载入文件中包含的inc
def loadInc(dirname,filename):
	try:
		f = open(dirname+"/"+filename);
	except:
		return ([],[])
	p = re.compile("^\s*function\s*(.*)\s*\(.*\)")
	incp = re.compile("^\s*include\s*\(\s*(?:\"|\')\s*(.*)\s*(?:\"|\')\s*\)");
	funcs = []
	incs = []
	for line in f:
		m = p.match(line)
		if m:
			funcs.append(m.group(1).strip());
		n = incp.match(line)
		if n:
			incs.append(n.group(1).strip());
	f.close();
	return (funcs,incs)

#递归函数
def getFuncPath(func,dirname,filename,cusfuncs,incs,path):
	#现在本文件中包含函数中的放去找
	#flag为true时，停止回溯
	path.append(filename)
	if func in cusfuncs:
		return True
	if len(incs)!=0:
		for inc in incs:
			filename = inc
			cusfuncs,incs = loadInc(dirname,filename);
			flag = getFuncPath(func,dirname,filename,cusfuncs,incs,path)
			if flag == False:
				continue
			else:
				return True
	path.pop();
	return False;
#开始解析函数了，获得函数的调用链
#文件名，函数名，自定义函数，头文件，路径
def getFunctionPath(dirname,filename,funcs):
	cusfuncs,incs =  loadInc(dirname,filename)
	# for func in funcs:
	funcAndPath = {}
	for func in funcs:
		if func in sys_funcs:
			funcAndPath[func] = ['system']
			continue
		path = []
		getFuncPath(func,dirname,filename,cusfuncs,incs,path)
		funcAndPath[func] = path;
	return funcAndPath
#从文件中得到所有调用
def getAllFuncs(dirname,filename):
	funcs = []
	#nasl插件中foreachs和cusfuncs是类似的
	foreachs  = []
	try:
		f = open(dirname+"/"+filename);
	except:
		return []
	allows="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_"
	for line in f:
		#注释
		index = line.find('#');
		if index >=0:
			line = line[0:index];
		#初始化描点
		start,end = 0,0;
		addForeaches(line,foreachs);
		#用于表示引号
		q = ''
		while(end < len(line) or start < len(line)):
			#开始移动start描点
			while(start<len(line)):
				#首先判断之前是否有引号，若是，就要先找到另一半，因为引号里面的函数都不算
				if len(q)!=0 and line[start]!=q:
					start+=1
					continue
				else:
					q = ''
				if line[start] in allows:
					break;
				#若是引号，则查找下一个引号,引号可能在下一行
				if line[start] == "'" or line[start]=='"':
					#可能为单引号，也可能为双引号
					q = line[start]
					start+=1
					continue
				start +=1
			#开始移动end描点
			end = start+1
			#表示这个end是否能够被用来解析
			endflag = False;
			while(end<len(line)):
				if line[end]=='(':
					endflag = True;
					break;
				#如果是空格的话还需格外处理
				if line[end] == ' ':
					#查找下一个非空格字符是否是(,这是为了处理向fun        ()的情况
					end += 1
					#可能有以下情况，遇到(,或者遇到' '，其他都不行
					while(end < len(line)):
						if line[end]=='(':
							endflag = True
							break;
						elif line[end]==' ':
							end += 1
						else:
							break;
					if endflag == False:
						break;
				if line[end] not in	allows:
					break;
				end +=1
			if (endflag == True):
				func = line[start:end].strip()
				if func not in funcs:
					funcs.append( func );
			start = end

	foreachs = foreachs + ['if','while',"for","else","elif"]
	for foreach in foreachs:
		if foreach in funcs:
			funcs.remove(foreach)
	#解析系统调用
	return funcs
def delSysFunc(funcs,sys_funcs):
	removeFuncs = []
	for func in funcs:
		if func in sys_funcs:
			removeFuncs.append(func)
	#移除系统调用
	for func in removeFuncs:
		funcs.remove(func)
	return funcs;
#获取未定义函数
def getUndefinedFunc(funcs):
	undefined = []
	for func in funcs:
		if funcs[func] == None or len(funcs[func])==0:
			undefined.append(func)
	return undefined;
#格式化输出,funcs是一个map
def printFuncs(funcs):
	if not funcs or len(funcs)==0:
		print "no function"
		return
	for func in funcs:
		print func,funcs[func]
def printUndefinedFuncs(funcs):
	print funcs
if __name__ == '__main__':
	opts,args = getopt.getopt(sys.argv[1:],'hf:d:usa');
	filename = ""
	dirname = "."
	flag = "a"
	for op, value in opts:
		if op == "-f":
			filename = value
		elif op == "-d":
			dirname = value
		elif op == '-u':
			flag = 'u'
		elif op == '-s':	
			flag = "s"
		elif op == '-a':
			flag = 'a'
		elif op == "-h":
			print """python parseFunc.py \n
			-d dirname\n
			-f filename\n
			-u undefined function\n
			-s without system function\n
			-a all function\n"""
			sys.exit()
	funcs = getAllFuncs(dirname,filename)
	if	flag == "a":
		printFuncs(getFunctionPath(dirname,filename,funcs))
		sys.exit()
	funcs = delSysFunc(funcs,sys_funcs);
	if  flag == "s":
		printFuncs(getFunctionPath(dirname,filename,funcs))
	if flag == "u":
		funcs = getUndefinedFunc(getFunctionPath(dirname,filename,funcs));
		printUndefinedFuncs(funcs)

#我的代码很丑，但是我很温柔




